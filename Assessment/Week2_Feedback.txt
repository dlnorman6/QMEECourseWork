Starting weekly assessment for Danielle, Week2

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 1.52 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week1, Assessment, Week2, Week3_R, .git

Found the following files in parent directory: README.txt, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
*.log
*.pyc
*pycache/
*results/**
*sandbox/**
*Sandbox/**
*.pdf
**********************************************************************

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
My QMEE Coursework Repository
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: Week1, Week2, Week3_R

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Code, Sandbox, data, results

Found the following files: 

Checking for readme file in weekly directory...

README file missing, 1 pt deducted

Current Points = 99

Found following files in results directory: FastaAligned.csv, JustOaksData.csv, BetterAligned.csv, BestAlign.csv, readme.txt...
ideally, Results directory should be empty other than, perhaps, a readme. 

Found 22 code files: lc2.py, boilerplate.py, basic_csv.py, cfexercises2.py, align_seqs_better.py, dictionary.py, debugme.py, scope.py, cfexercises1.py, tuple.py, basic_io.py, lc1.py, oaks_debugme.py, oaks.py, readme.txt, loops.py, using_name.py, align_seqs.py, sysargv.py, align_seqs_fasta.py, control_flow.py, test_control_flow.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Creates a list of [month,rainfall] tuples in which rainfall was greater than 100mm according to 1910 rainfall data from the metoffice, and a separate list of months in which rainfall was less than 50mm. The same lists are created using list comprehension and conventional loops."""

__appname__ = 'lc2.py'
__author__ = 'Danielle Norman (daniellenorman6@gmail.com)'
__version__ = '0.0.1'

## Data
# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )

## Script

## (1) create list of [month, rainfall] tuples where rainfall > 100mm using list comprehension

rain100plus_lc = [row for row in rainfall if row[1] > 100]
print(rain100plus_lc)

## (2) create list of months in which rainfall < 50mm using list comprehension

rain50less_lc = [row[0] for row in rainfall if row[1] < 50]
print(rain50less_lc)

## (3) repeat (1) and (2) above using conventional loops

rain100plus = [] # initialise list for records of rain >100mm
for row in rainfall: # cycle through rainfall data
    if row[1] > 100: 
        rain100plus.append(row) # append month and rainfall entry to list
print(rain100plus)

rain50less = [] # initialise list for records of rain <50mm
for row in rainfall: # cycle through rainfall data
    if row[1] < 50:
        rain50less.append(row[0]) # append month only to list
print(rain50less)


**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']
[('JAN', 111.4), ('FEB', 126.1), ('AUG', 140.2), ('NOV', 128.4), ('DEC', 142.2)]
['MAR', 'SEP']

**********************************************************************

Code ran without errors

Time consumed = 0.01280s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Description: boilerplate for python"""

__appname__ = 'boilerplate'
__author__ = 'Danielle Norman (daniellenorman6@gmail.com)'
__version__ = '0.0.1'
__license__ = ''

## Imports ##
import sys # module to interface our program with the OS

## Constants ##


## Functions ##
def main(argv):
    """ Main entry point of the program """
    print('This is a boilerplate') # Note: indented
    return 0

if __name__ == "__main__":
    """Makes sure the "main" function is called from command line"""
    status = main(sys.argv)
    sys.exit(status)
    **********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.01298s

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
"""Examples of reading and writing csv files in python"""

import csv

# Read a file containing:
# 'Species','Infraorder','Family','Distribution','Body mass male (Kg)'
f = open('../data/testcsv.csv','r')

csvread = csv.reader(f)
temp = []
for row in csvread:
    temp.append(tuple(row))
    print(row)
    print("The species is",row[0])

f.close()

# Write a file containing only species name and body mass
f = open('../data/testcsv','r')
g = open('../data/bodymass.csv','w')

csvread = csv.reader(f)
csvwrite = csv.writer(g)
for row in csvread:
    print(row)
    csvwrite.writerow([row[0],row[4]])

f.close()
g.close()**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Traceback (most recent call last):
  File "basic_csv.py", line 7, in <module>
    f = open('../data/testcsv.csv','r')
IOError: [Errno 2] No such file or directory: '../data/testcsv.csv'

======================================================================
Inspecting script file cfexercises2.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Some functions illustrating control flow"""

__appname__ = 'cfexercises2.py'
__author__ = 'Danielle Norman (daniellenorman6@gmail.com)'
__version__ = '0.0.1'

## Imports ##
import sys

def foo1(x):
    """Returns the square root of x"""
    s = x ** 0.5
    return "The square root of %d is %f" % (x,s)

def foo2(x,y): 
    """Returns the largest value in the pair"""
    if x > y:
        return "%f is larger than %f" % (x,y)
    return "%f is larger than %f" % (y,x)

def foo3(x, y, z):
    """Reorders such that the largest value appears at the end"""
    x1 = x; y1 = y; z1 = z
    if x > y:
        tmp = y
        y = x
        x = tmp
    if y > z:
        tmp = z
        z = y
        y = tmp
    return "The largest number in [%f,%f,%f] is %f" %(x1, y1, z1, z)

def foo4(x):
    """Returns x!"""
    result = 1
    for i in range(1, x + 1):
        result = result * i
    return "%f! is %f" % (x,result)

def foo5(x):
    """Calculates x! recursively""" 
    if x == 1:
        return 1
    return x * foo5(x-1)

def foo6(x):
    """Calculates the factorial of x"""
    facto = 1
    while x >= 1:
        facto = facto * x
        x = x-1
    return facto

def main(argv):
    print(foo1(16))
    print(foo2(2,3))
    print(foo2(3,2))
    print(foo3(8,9,7))
    print(foo3(9,8,7))
    print(foo4(5))
    print(foo5(5))
    print(foo6(5))
    return 0

if __name__ == "__main__":
    """Makes sure the "main" function is called from command line"""
    status = main(sys.argv)
    sys.exit(status)

**********************************************************************

Testing cfexercises2.py...

cfexercises2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
The square root of 16 is 4.000000
3.000000 is larger than 2.000000
3.000000 is larger than 2.000000
The largest number in [8.000000,9.000000,7.000000] is 9.000000
The largest number in [9.000000,8.000000,7.000000] is 9.000000
5.000000! is 120.000000
120
120

**********************************************************************

Code ran without errors

Time consumed = 0.01413s

======================================================================
Inspecting script file align_seqs_better.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

""" Computes the best match, or matches if multiple have positions have the same score, and prints all matches to output file "../results/BetterAligned.csv:" """

__appname__ = 'align_seqs_better.py'
__author__ = 'Danielle Norman (daniellenorman6@gmail.com)'
__version__ = '0.0.1'

import csv
import sys
import pdb
import doctest
import pickle

def calculate_score(s1, s2, l1, l2, startpoint):
    """Calculates the number of base matches, i.e. score, in two DNA sequences for each possible starting position"""
    # startpoint is the point at which we want to start
    matched = "" # contains string for alignment
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            # if its matching the character
            if s1[i + startpoint] == s2[i]:
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"
    return score

def main(argv): 
    if len(sys.argv) > 1:
        f1 = open(sys.argv[1],'r')
        f2 = open(sys.argv[2],'r')
    else:
        f1 = open('../../Week1/Data/407228326.fasta','r')
        f2 = open('../../Week1/Data/407228412.fasta','r')
    
    g = open('../results/BetterAligned.csv','w') # output file
    csvwrite = csv.writer(g)

    seq1 = ''
    for row in f1:
        if row.startswith('>'):
            continue
        seq1 = seq1 + row
    seq1 = seq1.replace("\n","")

    seq2 = ''
    for row in f2:
        if row.startswith('>'):
            continue
        seq2 = seq2 + row
    seq2 = seq2.replace("\n","")
 
    l1 = len(seq1)
    l2 = len(seq2)
    if l1 >= l2:
        s1 = seq1
        s2 = seq2
    else:
        s1 = seq2
        s2 = seq1
        l1, l2 = l2, l1 # swap the two lengths

    # now try to find the best match (highest score)
    my_best_align = None
    my_best_score = -1

    matches = [] # empty list
    for i in range(l1):
        z = calculate_score(s1, s2, l1, l2, i)
        if z > my_best_score: # start list again
            my_best_align = "." * i + s2
            my_best_score = z
            matches = [my_best_align]
        elif z == my_best_score: # add match to list of matches with same score
            my_best_align = "." * i + s2
            matches.append(my_best_align)
    
    print(len(matches)) # print number of matches
  
    csvwrite.writerow(matches)
    csvwrite.writerow([s1])
    csvwrite.writerow(["Best score:", my_best_score])

    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)    
**********************************************************************

Testing align_seqs_better.py...

align_seqs_better.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
1

**********************************************************************

Code ran without errors

Time consumed = 2.23838s

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Creates a dictionary from a list of tuples of form [taxa, order] such that sets of taxa are matched to each order"""

__appname__ = 'dictionary.py'
__author__ = 'Danielle Norman (daniellenorman6@gmail.com)'
__version__ = '0.0.1'

## Data

taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ]


## Script
orders = set() # initialise list of orders
for row in taxa: # extract orders from tuples
    orders.add(row[1])
order = list(orders) # change to list so that it can be indexed in next loop

taxa_dic = {} # initialise dictionary
for o in order: # loop through orders
    tmp = set()
    for row in taxa: # loop through taxas
        if row[1] == o: # if species belongs to order
            tmp.add(row[0])
    taxa_dic[o] = tmp # add order and set of taxas to dictionary

print(taxa_dic)**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
{'Rodentia': set(['Peromyscus crinitus', 'Mus domesticus', 'Gerbillus henleyi', 'Cleithrionomys rutilus']), 'Afrosoricida': set(['Microgale dobsoni', 'Microgale talazaci']), 'Chiroptera': set(['Myotis lucifugus']), 'Carnivora': set(['Arctocephalus gazella', 'Lyacon pictus', 'Canis lupus'])}

**********************************************************************

Code ran without errors

Time consumed = 0.01397s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Illustrative function with a bug to practice debugging"""
def createabug(x):
    y = x**4
    z = 0.
    y = y/z
    return y

createabug(25)**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Traceback (most recent call last):
  File "debugme.py", line 10, in <module>
    createabug(25)
  File "debugme.py", line 7, in createabug
    y = y/z
ZeroDivisionError: float division by zero

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
## Try this first

_a_global = 10 # Not actually global, only in name

def a_function():
    _a_global = 5
    _a_local = 4
    print("Inside the function, the value is ", _a_global)
    print("Inside the function, the value is ", _a_local)
    return None

a_function()

print("Outside the function, the value is ", _a_global)

## Now try this

_a_global = 10

def a_function():
    global _a_global
    _a_global = 5
    _a_local = 4
    print("Inside the function, the value is ", _a_global)
    print("Inside the function, the value is ", _a_local)
    return None

a_function()

print("Outside the function, the value is ", _a_global)
**********************************************************************

Testing scope.py...

scope.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 98

Output (only first 500 characters): 

**********************************************************************
('Inside the function, the value is ', 5)
('Inside the function, the value is ', 4)
('Outside the function, the value is ', 10)
('Inside the function, the value is ', 5)
('Inside the function, the value is ', 4)
('Outside the function, the value is ', 5)

**********************************************************************

Code ran without errors

Time consumed = 0.01607s

======================================================================
Inspecting script file cfexercises1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Control flow examples: for and while loops"""

# Desc: number of hello's printed
for i in range(3,17): #14
    print('hello')

for j in range(12): #4
    if j % 3 == 0:
        print('hello')

for j in range(15): #5
    if j % 5 == 3:
        print('hello')
    elif j % 4 == 3:
        print('hello')

z = 0
while z != 15: #5
    print('hello')
    z = z + 3

z = 12
while z < 100: #8
    if z == 31:
        for k in range(7):
            print('hello')
    elif z == 18:
        print('hello')
    z = z + 1
**********************************************************************

Testing cfexercises1.py...

cfexercises1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello

**********************************************************************

Code ran without errors

Time consumed = 0.01567s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Prints the tuples given in a list of tuples on separate lines."""

__appname__ = 'tuple.py'
__author__ = 'Danielle Norman (daniellenorman6@gmail.com)'
__version__ = '0.0.1'

## Data
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

## Script 

for row in birds:
    print(row)
    print("")**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
('Passerculus sandwichensis', 'Savannah sparrow', 18.7)

('Delichon urbica', 'House martin', 19)

('Junco phaeonotus', 'Yellow-eyed junco', 19.5)

('Junco hyemalis', 'Dark-eyed junco', 19.6)

('Tachycineata bicolor', 'Tree swallow', 20.2)


**********************************************************************

Code ran without errors

Time consumed = 0.01138s

======================================================================
Inspecting script file basic_io.py...

File contents are:
**********************************************************************

"""Examples of reading in .txt files, skipping lines, saving list elements to .txt files, and pickle"""
#################
# FILE INPUT
#################
# Open a file for reading
f=open('../Sandbox/test.txt','r')
# use "implicit" for loop:
# if the object is a file, python will cycle over loop
for line in f:
	print(line)

# close the file
f.close()

# Same example, skip blank lines
f = open('../Sandbox/test.txt','r')
for line in f:
    if len(line.strip())>0:
        print(line)

f.close()

################
# FILE OUTPUT
################
# Save the elements of a list to a file
list_to_save = range(100)

f = open('../Sandbox/testout.txt','w')
for i in list_to_save:
	f.write(str(i) + '\n') ## Add a new line at the end

f.close()

################
# STORING OBJECTS
################
# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

import pickle

f = open('../Sandbox/testp.p','wb') ## note the b: accept binary files
pickle.dump(my_dictionary,f)
f.close()

## Load the data again
f = open('../Sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print(another_dictionary)**********************************************************************

Testing basic_io.py...

basic_io.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
First Line

Second Line



Third Line



Fourth Line

First Line

Second Line

Third Line

Fourth Line

{'another key': 11, 'a key': 10}

**********************************************************************

Code ran without errors

Time consumed = 0.02214s

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Creates three separate sets containing the latin name, common name, and body mass, respectively, for bird data given in the form of tuples [latin name, common name, body mass]. In part 1, the sets are formed via list comprehensions, and in part 2, through the use of for loops."""

__appname__ = 'lc1.py'
__author__ = 'Danielle Norman (daniellenorman6@gmail.com)'
__version__ = '0.0.1'

## Data
birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )

##### Script
## (1): using list comprehensions

birds_latin_lc = set([row[0] for row in birds]) # extract latin names
print(birds_latin_lc)

birds_common_lc = set([row[1] for row in birds]) # extract common names
print(birds_common_lc)

birds_mass_lc = set([row[2] for row in birds]) # extract body masses
print(birds_mass_lc)

## (2): using conventional for loops

birds_latin = set() # initialise set for latin names
for row in birds: # loop over data set
    birds_latin.add(row[0]) # extract latin names
print(birds_latin)

birds_common = set() # initialise set for common names
for row in birds: # loop over data set
    birds_common.add(row[1]) # extract common names
print(birds_common)

birds_mass = set() # initialise set for body masses
for row in birds: # loop over data set
    birds_mass.add(row[2]) # extract body mass
print(birds_mass)**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
set(['Junco hyemalis', 'Passerculus sandwichensis', 'Junco phaeonotus', 'Tachycineata bicolor', 'Delichon urbica'])
set(['Savannah sparrow', 'House martin', 'Dark-eyed junco', 'Yellow-eyed junco', 'Tree swallow'])
set([19.5, 20.2, 19, 18.7, 19.6])
set(['Junco hyemalis', 'Passerculus sandwichensis', 'Junco phaeonotus', 'Tachycineata bicolor', 'Delichon urbica'])
set(['Savannah sparrow', 'House martin', 'Dark-eyed junco', 'Yellow-eyed junco', 'Tree swallow'])
set([19.5, 20.2, 19, 18.7, 19.6])

**********************************************************************

Code ran without errors

Time consumed = 0.01672s

======================================================================
Inspecting script file oaks_debugme.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Identifies oaks from a dataset and saves to output file"""

__appname__ = 'oaks_debugme.py'
__author__ = 'Danielle Norman (daniellenorman6@gmail.com)'
__version__ = '0.0.1'

import csv
import sys
import pdb
import doctest

#Define function
def is_an_oak(name):
    """ Returns True if name starts with 'quercus' 
    
    >>> is_an_oak('Fagus sylvatica')
    False

    >>> is_an_oak('Quercus test')
    True

    >>> is_an_oak('Quercuss test')
    False
    """
    return name.lower().split(" ")[0] == 'quercus'

def main(argv): 
    f = open('../data/TestOaksData.csv','r')
    g = open('../results/JustOaksData.csv','w') # output file
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    oaks = set()
    for row in taxa:
        if row[0] == 'Genus': # write header to output file
            csvwrite.writerow([row[0], row[1]])
        else:
            print(row)
            print("The genus is: ") 
            print(row[0])
            if is_an_oak(row[0]): # write oaks to output file
                print('FOUND AN OAK!')
                csvwrite.writerow([row[0], row[1]])
            print("") 

    return 0
    
if (__name__ == "__main__"):
    status = main(sys.argv)**********************************************************************

Testing oaks_debugme.py...

oaks_debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Quercus', ' robur']
The genus is: 
Quercus
FOUND AN OAK!

['Fraxinus', ' excelsior']
The genus is: 
Fraxinus

['Pinus', ' sylvestris']
The genus is: 
Pinus

['Quercus', ' cerris']
The genus is: 
Quercus
FOUND AN OAK!

['Quercus', ' petraea']
The genus is: 
Quercus
FOUND AN OAK!


**********************************************************************

Code ran without errors

Time consumed = 0.04528s

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Finds just those taxa that are oak trees from a list of species"""

taxa = ['Quercus robur',
        'Fraxinus excelsior',
        'Pinus sylvestris',
        'Quercus cerris',
        'Quercus petraea',
        ]

def is_an_oak(name):
    return name.lower().startswith('quercus ')

## Using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species)
print(oaks_loops)

## Using list comprehensions
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print(oaks_lc)

## Get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:
    if is_an_oak(species):
        oaks_loops.add(species.upper())
print(oaks_loops)

## Get names in UPPER CASE using list comprehensions
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)])
print(oaks_lc)**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
set(['Quercus robur', 'Quercus cerris', 'Quercus petraea'])
set(['Quercus robur', 'Quercus cerris', 'Quercus petraea'])
set(['QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'])
set(['QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'])

**********************************************************************

Code ran without errors

Time consumed = 0.01638s

======================================================================
Inspecting script file readme.txt...

File contents are:
**********************************************************************
Index and description of files:
## Worked examples
- basic_csv.py: Examples of reading and writing csv files in python
- basic_io.py: Examples of reading in .txt files, skipping lines, saving list elements to .txt files, and pickle
- boilerplate.py: boilerplate for python
- cfexercises1.py: Loop examples: for and while
- control_flow.py: Some functions exemplifying the use of control statements
- debugme.py: Simple function with a bug for testing debugging on
- loops.py: Loop examples
- oaks.py: Returns just oaks from a list of tree species
- scope.py: Illustrates use of local/global variables
- sysargv.py: Illustrates the use of sys.argv
- test_control_flow.py: Illustrates the use of doctest
- using_name.py: Illustrates __name__ change using run vs import  

## Practicals
- align_seqs.py: Aligns two DNA sequences stored in a single data file and outputs the first occurring best match
- align_seqs_better.py: Aligns two DNA sequences stored in a single data file and outputs all matches that achieve the best score
- align_seqs_fasta.py: Takes fasta files as defaults and identifies the best alignment
- cfexercises2.py: Functions illustrating control flow
- dictionary.py: Creates a dictionary from a list of tuples
- lc1.py: List comprehensions: creates sets from data
- lc2.py: List comprehensions: creates list of tuples from data
- oaks_debugme.py: Identifies oaks from a dataset and saves to output file
- tuple.py: Prints the tuples in a list on separate lines

 



**********************************************************************

Testing readme.txt...

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

# FOR loops in Python
for i in range(5):
    print(i)

my_list = [0, 2, "geronimo!", 3.0, True, False]
for k in my_list:
    print(k)

total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
    total  = total + s
    print(total)

# WHILE loops in Python
z = 0
while z < 100:
    z = z + 1
    print(z)

b = True
while b:
    print("GERONIMO! infinite loop! ctrl+c to stop!")**********************************************************************

Testing loops.py...

loops.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 97

Output (only first 500 characters): 

**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
1
12
123
1234
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c
**********************************************************************

Code ran without errors

Time consumed = 10.62228s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3
# Filename: using_name.py

if __name__ == '__main__':
    print('This program is being run by itself')
else:
    print('I am being imported from another module')
**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 96

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself

**********************************************************************

Code ran without errors

Time consumed = 0.07491s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Aligns two DNA sequences stored in a single data file such that they are as similar as possible and outputs the best alignment along with its score (number of base matches) to file '../results/BestAlign.csv' """ 

__appname__ = 'align_seqs.py'
__author__ = 'Danielle Norman (daniellenorman6@gmail.com)'
__version__ = '0.0.1'

import csv
import sys
import pdb
import doctest


def calculate_score(s1, s2, l1, l2, startpoint):
    """Calculates the number of base matches, i.e. score, in two DNA sequences for each possible starting position"""
    # startpoint is the point at which we want to start
    matched = "" # contains string for alignment
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            # if its matching the character
            if s1[i + startpoint] == s2[i]:
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    # build some formatted output
    print("." * startpoint + matched)           
    print("." * startpoint + s2)
    print(s1)
    print(score)
    print("")

    return score

def main(argv): 
    f = open('../data/SeqsToAlign.csv','r')
    g = open('../results/BestAlign.csv','w')
    data = csv.reader(f)
    csvwrite = csv.writer(g)

    # These are the two sequences to match
    seq = []
    for row in data:
        seq.append(row)
    seq2 = seq[0][0]
    seq1 = seq[1][0]

    print(seq1)

    # assign the longest sequence s1, with length l1, and the shortest to s2, with length l2

    l1 = len(seq1)
    l2 = len(seq2)
    if l1 >= l2:
        s1 = seq1
        s2 = seq2
    else:
        s1 = seq2
        s2 = seq1
        l1, l2 = l2, l1 # swap the two lengths


    # calculate_score(s1, s2, l1, l2, 0)
    # calculate_score(s1, s2, l1, l2, 1)
    # calculate_score(s1, s2, l1, l2, 5)

    # now try to find the best match (highest score)
    my_best_align = None
    my_best_score = -1

    for i in range(l1):
        z = calculate_score(s1, s2, l1, l2, i)
        if z > my_best_score:
            my_best_align = "." * i + s2
            my_best_score = z

    csvwrite.writerow([my_best_align])
    csvwrite.writerow([s1])
    csvwrite.writerow(["Best score:", my_best_score])
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)    
**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
CAATTCGGAT
-----*****
CAATTCGGAT
ATCGCCGGATTACGGG
5

.------*--*
.CAATTCGGAT
ATCGCCGGATTACGGG
2

..*---------
..CAATTCGGAT
ATCGCCGGATTACGGG
1

...--------*-
...CAATTCGGAT
ATCGCCGGATTACGGG
1

....*---------
....CAATTCGGAT
ATCGCCGGATTACGGG
1

.....*---*-----
.....CAATTCGGAT
ATCGCCGGATTACGGG
2

......--***--*--
......CAATTCGGAT
ATCGCCGGATTACGGG
4

.......-*-*-***-
.......CAATTCGGAT
ATCGCCGGATTACGGG
5

........------**
........CAATTCGGAT
ATCGCCGGATTACGGG
2

.........--*---*
.........CAATTCGGAT
ATCGCC
**********************************************************************

Code ran without errors

Time consumed = 0.03450s

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

import sys
print("This is the name of the script: ", sys.argv[0])
print("Number of arguments: ", len(sys.argv))
print("The arguments are: ", str(sys.argv))




**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;
 checking for docstrings...

Found no doctrings!
1 pt deducted

Current Points = 95

Output (only first 500 characters): 

**********************************************************************
('This is the name of the script: ', 'sysargv.py')
('Number of arguments: ', 1)
('The arguments are: ', "['sysargv.py']")

**********************************************************************

Code ran without errors

Time consumed = 0.01388s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Aligns two sequences of DNA saved in separate files. Default files are fasta files saved in the data directory. The best alignment and corresponding number of base matches (score) is outputted to file."""

__appname__ = 'align_seqs_fasta.py'
__author__ = 'Danielle Norman (daniellenorman6@gmail.com)'
__version__ = '0.0.1'

import csv
import sys
import pdb
import doctest

def calculate_score(s1, s2, l1, l2, startpoint):
    """Calculates the number of base matches, i.e. score, in two DNA sequences for each possible starting position"""    
    # startpoint is the point at which we want to start
    matched = "" # contains string for alignment
    score = 0
    for i in range(l2):
        if (i + startpoint) < l1:
            # if its matching the character
            if s1[i + startpoint] == s2[i]:
                matched = matched + "*"
                score = score + 1
            else:
                matched = matched + "-"

    return score

def main(argv): 
    if len(sys.argv) > 1: # if files specified, open
        f1 = open(sys.argv[1],'r')
        f2 = open(sys.argv[2],'r')
    else: # else use default files
        f1 = open('../../Week1/Data/407228326.fasta','r')
        f2 = open('../../Week1/Data/407228412.fasta','r')
    
    g = open('../results/FastaAligned.csv','w') # output file
    csvwrite = csv.writer(g)

    ## Extract sequences from files
    seq1 = ''
    for row in f1:
        if row.startswith('>'):
            continue
        seq1 = seq1 + row
    seq1 = seq1.replace("\n","")

    seq2 = ''
    for row in f2:
        if row.startswith('>'):
            continue
        seq2 = seq2 + row
    seq2 = seq2.replace("\n","")
 
    # assign the longest sequence s1, with length l1 and the shortest to s2, with length l2
    l1 = len(seq1)
    l2 = len(seq2)
    if l1 >= l2:
        s1 = seq1
        s2 = seq2
    else:
        s1 = seq2
        s2 = seq1
        l1, l2 = l2, l1 

    # now try to find the best match (highest score)
    my_best_align = None
    my_best_score = -1

    for i in range(l1):
        z = calculate_score(s1, s2, l1, l2, i)
        if z > my_best_score:
            my_best_align = "." * i + s2
            my_best_score = z

    csvwrite.writerow([my_best_align])
    csvwrite.writerow([s1])
    csvwrite.writerow(["Best score:", my_best_score])
    return 0

if (__name__ == "__main__"):
    status = main(sys.argv)    
**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 2.27130s

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Some functions exemplifying the use of control statements"""
#docstrings are considered part of the running code (normal comments are
#stripped). Hence, you can access your docstrings at run time.

__appname__ = 'control_flow.py'
__author__ = 'Danielle Norman (daniellenorman6@gmail.com)'
__version__ = '0.0.1'

## Imports ##
import sys # module to interface our program with the OS

## Constants ##


## Functions ##
def even_or_odd(x=0): # if not specified, x should take value 0
    """Find whether a number x is even or odd."""
    if x % 2 == 0: # The conditional if
        return "%d is Even!" % x
    return "%d is Odd!" % x

def largest_divisor_five(x=120):
    """Find which is the largest divisor of x among 2,3,4,5."""
    largest = 0
    if x % 5 == 0:
        largest = 5
    elif x % 4 == 0: # means "else, if"
        largest = 4
    elif x % 3 == 0:
        largest = 3
    elif x % 2 == 0:
        largest = 2
    else: # When all other (if, elif) conditions are not met
        return "No divisor found for %d!" % x # Each function can return a value or a variable.
    return "The largest divisor of %d is %d" % (x, largest)

def is_prime(x=70):
    """Find whether an integer is prime."""
    for i in range(2,x): # returns a sequence of integers
        if x % i == 0:
            print("%d is not a prime: %d is a divisor" % (x, i)) #Print formatted text "%d %s %f %e" % (20,"30",0.0003,0.00003)
            return False    
    print("%d is a prime!" % x)
    return True

def find_all_primes(x=22):
    """Find all the primes up to x."""
    allprimes = []
    for i in range(2,x+1):
        if is_prime(i):
            allprimes.append(i)
    print("There are %d primes between 2 and %d" % (len(allprimes),x))
    return allprimes

def main(argv):
    print(even_or_odd(22))
    print(even_or_odd(33))
    print(largest_divisor_five(120))
    print(largest_divisor_five(121))
    print(is_prime(60))
    print(is_prime(59))
    print(find_all_primes(100))
    return 0

if __name__ == "__main__":
    """Makes sure the "main" function is called from command line"""
    status = main(sys.argv)
    sys.exit(status)
    **********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.01265s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#!/usr/bin/env python3

"""Illustrates the use of doctest on control_flow.py"""
#docstrings are considered part of the running code (normal comments are
#stripped). Hence, you can access your docstrings at run time.

__appname__ = 'control_flow.py'
__author__ = 'Danielle Norman (daniellenorman6@gmail.com)'
__version__ = '0.0.1'

## Imports ##
import sys # module to interface our program with the OS
import doctest

## Constants ##


## Functions ##
def even_or_odd(x=0): # if not specified, x should take value 0
    """Find whether a number x is even or odd.
    >>> even_or_odd(10)
    '10 is Even!'

    >>> even_or_odd(5)
    '5 is Odd!'

    >>> even_or_odd(3.2)
    '3 is Odd!'

    >>> even_or_odd(-2)
    '-2 is Even!'
    """
    # Define function to be tested
    if x % 2 == 0: # The conditional if
        return "%d is Even!" % x
    return "%d is Odd!" % x

# def largest_divisor_five(x=120):
#     """Find which is the largest divisor of x among 2,3,4,5."""
#     largest = 0
#     if x % 5 == 0:
#         largest = 5
#     elif x % 4 == 0: # means "else, if"
#         largest = 4
#     elif x % 3 == 0:
#         largest = 3
#     elif x % 2 == 0:
#         largest = 2
#     else: # When all other (if, elif) conditions are not met
#         return "No divisor found for %d!" % x # Each function can return a value or a variable.
#     return "The largest divisor of %d is %d" % (x, largest)

# def is_prime(x=70):
#     """Find whether an integer is prime."""
#     for i in range(2,x): # returns a sequence of integers
#         if x % i == 0:
#             print("%d is not a prime: %d is a divisor" % (x, i)) #Print formatted text "%d %s %f %e" % (20,"30",0.0003,0.00003)
#             return False    
#     print("%d is a prime!" % x)
#     return True

# def find_all_primes(x=22):
#     """Find all the primes up to x."""
#     allprimes = []
#     for i in range(2,x+1):
#         if is_prime(i):
#             allprimes.append(i)
#     print("There are %d primes between 2 and %d" % (len(allprimes),x))
#     return allprimes

# def main(argv):
#     print(even_or_odd(22))
#     print(even_or_odd(33))
#     print(largest_divisor_five(120))
#     print(largest_divisor_five(121))
#     print(is_prime(60))
#     print(is_prime(59))
#     print(find_all_primes(100))
#     return 0

doctest.testmod()
# if __name__ == "__main__":
#     """Makes sure the "main" function is called from command line"""
#     status = main(sys.argv)
#     sys.exit(status)
    **********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.04750s

======================================================================
======================================================================
Finished running scripts

Ran into 2 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 95

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!